"use strict";(self.webpackChunkduelink=self.webpackChunkduelink||[]).push([[2968],{6977:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"engine/daisylink","title":"Daisylink","description":"---","source":"@site/docs/engine/daisylink.mdx","sourceDirName":"engine","slug":"/engine/daisylink","permalink":"/docs/engine/daisylink","draft":false,"unlisted":false,"editUrl":"https://github.com/ghi-electronics/duelink-website/tree/dev/docs/engine/daisylink.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Standalone","permalink":"/docs/engine/standalone"},"next":{"title":"Stream","permalink":"/docs/engine/stream"}}');var t=s(4848),d=s(8453);const o={},r="Daisylink",c={},l=[{value:"Device Selection",id:"device-selection",level:2},{value:"Broadcast",id:"broadcast",level:2},{value:"Device Addressing",id:"device-addressing",level:2},{value:"Module to Module Commands",id:"module-to-module-commands",level:2},{value:"Host Mode",id:"host-mode",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",p:"p",pre:"pre",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"daisylink",children:"Daisylink"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/uplink-downlink.png",alt:"Uplink-Downlink"})}),"\n",(0,t.jsxs)(n.p,{children:["In a DUELink setup, where there are more than one module, there will always be a connection between the Uplink and Downlink sockets. The limit of connected devices is 255 devices. And if you need more, use another ",(0,t.jsx)(n.a,{href:"../interface/intro",children:"Interface"})," to add another 255 devices! Also, each single module in a chain is an active repeater of the signal. There will be no degradation of the signal quality. If necessary, add ",(0,t.jsx)(n.a,{href:"../catalog/accessory/power-inject",children:"Power Inject"})," to help with power.\r\n",(0,t.jsx)(n.img,{src:"/img/daisylink.png",alt:"Daisylink"})]}),"\n",(0,t.jsx)(n.h2,{id:"device-selection",children:"Device Selection"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"./stdlib",children:"Standard Library"})," offers the ",(0,t.jsx)(n.code,{children:"Sel()"})," command to activate devices on the chain. To blink the status LED on the second device on the daisylink chain, use ",(0,t.jsx)(n.code,{children:"Sel(2)"})," followed by ",(0,t.jsx)(n.code,{children:"statled(200,200,50)"}),". The LED will blink 50 times on the second module in the stream."]}),"\n",(0,t.jsxs)(n.p,{children:["Daisylinked devices on a stream are addressed from ",(0,t.jsx)(n.code,{children:"1"}),". The fourth device on the bus is selected using 'Sel(4)'."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/select.png",alt:"Select"})}),"\n",(0,t.jsxs)(n.p,{children:["It is possible to select more than one device at once. Let's say we want to select devices 1,3 and 4 ",(0,t.jsx)(n.code,{children:"Sel(1,3,4)"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/multiple-select.png",alt:"Multiple Select"})}),"\n",(0,t.jsx)(n.h2,{id:"broadcast",children:"Broadcast"}),"\n",(0,t.jsx)(n.p,{children:"Address zero is a special address on the chain, which indicates a broadcast selection. During a broadcast, all modules are required to process the command."}),"\n",(0,t.jsx)(n.p,{children:"In this example, we have 4 modules connected."}),"\n",(0,t.jsxs)(n.p,{children:["Sending ",(0,t.jsx)(n.code,{children:"Sel(0)"})," followed by ",(0,t.jsx)(n.code,{children:"statled(200,200,50)"})," will blink the status LED 50 times on each one of the four modules. It is also possible to read from multiple devices. ",(0,t.jsx)(n.code,{children:'Sel(0):Print("Hi")'}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/broadcast.png",alt:"Broadcast"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Do not confuse the module address with ",(0,t.jsx)(n.a,{href:"../interface/i2c",children:"I2C"})," address. They are unrelated! The module address work the same no matter what ",(0,t.jsx)(n.a,{href:"../interface/intro",children:"Interface"})," is being used."]})}),"\n",(0,t.jsx)(n.h2,{id:"device-addressing",children:"Device Addressing"}),"\n",(0,t.jsxs)(n.p,{children:["When modules power up, they have a NULL interface, and they have no set address yet. Once an ",(0,t.jsx)(n.a,{href:"../interface/intro",children:"Interface"})," is selected, such as ",(0,t.jsx)(n.a,{href:"../interface/usb",children:"USB"}),", then the first device will set its own address to 1 and then command all downlink devices to take a new address, 1, 2, 3, 4...etc."]}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"GetAddr()"})," to read the current address. If the current address is zero, then the device has not been enumerated."]}),"\n",(0,t.jsx)(n.h2,{id:"module-to-module-commands",children:"Module to Module Commands"}),"\n",(0,t.jsxs)(n.p,{children:["DUELink is very flexible that things can get quite nifty! A Button can be programmed to run ",(0,t.jsx)(n.a,{href:"./standalone",children:"Standalone"}),", where this button sends commands to control an LED!"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/button-led.gif",alt:"Button Controlling LEDs"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Cmd()"})," is a special ",(0,t.jsx)(n.a,{href:"./stdlib",children:"Standard Library"})," command to send a command from the current device to all devices on the downlink. Of course, only devices that were selected using ",(0,t.jsx)(n.code,{children:"Sel()"})," will respond to commands. Any device in the daisylink can ",(0,t.jsx)(n.code,{children:"Cmd()"})," but the command will only be sent downlink."]}),"\n",(0,t.jsxs)(n.p,{children:["For demonstration, let us assume we have a Raspberry Pi Pico connected using I2C bus to Button, Accelerometer, and CP23 color display. Once Raspberry Pi starts communicating over I2C, the first device (button in this case) will detect the ",(0,t.jsx)(n.a,{href:"../interface/i2c",children:"I2C"}),". This first device will set its own address to 1 and then flag a new address protocol to all devices in the chain, resulting in Accelerometer with address 2, and CP23 Display with address 3"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/raspberrypi-button-accel-cp23.png",alt:"RaspberryPI Daisylinked"})}),"\n",(0,t.jsxs)(n.p,{children:["Assuming the display was selected by the host, where Raspberry Pi Pico sent ",(0,t.jsx)(n.code,{children:"Sel(3)"})," in this example, any downlink commands will now be processed by the display. Sending ",(0,t.jsx)(n.code,{children:"Circle(1,20,20,15):Show()"})," from the host, again RPI Pico, will result with a circle on the display. Now, any other modules, like the accelerometer can send similar commands, such as ",(0,t.jsx)(n.code,{children:'Cmd("Circle(1,40,30,35):Show()")'}),". Of course, the Accelerometer can get is own position and use that move the circle on the display. The button can similarly send ",(0,t.jsx)(n.code,{children:'Cmd("Clear(0):Show()")'})," to clear the screen."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/raspberrypi-cp23-circle.png",alt:"RaspberryPI Daisylinked"})}),"\n",(0,t.jsxs)(n.p,{children:["Sending ",(0,t.jsx)(n.code,{children:"Sel()"})," over ",(0,t.jsx)(n.code,{children:"Cmd()"})," is supported but can be tricky! The reason is that ",(0,t.jsx)(n.code,{children:"Sel()"})," is only sent downlink. Going back the previous example, let us assume RPI Pico has elected device 1 ",(0,t.jsx)(n.code,{children:"Sel(1)"})," (the button) but then the Accelerometer sent ",(0,t.jsx)(n.code,{children:'Cmd("Sel(3)"")'})," to select the Display. The ",(0,t.jsx)(n.code,{children:"Sel()"})," command sent by the Accelerometer is only seen by devices on downlink. The display in this case will be selected but so does the button."]}),"\n",(0,t.jsx)(n.p,{children:"All this comes in very handy in Host mode!"}),"\n",(0,t.jsx)(n.h2,{id:"host-mode",children:"Host Mode"}),"\n",(0,t.jsxs)(n.p,{children:["Typically, a host is used to command a stream of daisylinked devices. There are several ",(0,t.jsx)(n.a,{href:"../system/intro",children:"Supported Systems"})," and many supported ",(0,t.jsx)(n.a,{href:"../language/intro",children:"Languages"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/other-micros.png",alt:"Other Micros"})}),"\n",(0,t.jsxs)(n.p,{children:["DUELink modules can run ",(0,t.jsx)(n.a,{href:"../engine/standalone",children:"Standalone"})," and can also be the host of other daisylinked modules connected on the ",(0,t.jsx)(n.a,{href:"../interface/downlink",children:"Downlink"})," socket. The difference here is that the device that is the host, is not part of the stream, it is the host! Use ",(0,t.jsx)(n.code,{children:"Host()"})," command to activate this mode."]}),"\n",(0,t.jsx)(n.p,{children:"Once activated, the device configures and enumerates the devices downlink, starting with address 1. From this point, the host can address other devices."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/img/host-mode.png",alt:"Host Mode"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'Host() # Switch to host mode\r\nCmd("Sel(2)") # Select second device\r\nCmd("statled(200,200,50)") # Blink the LED 50 times on the selected device\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:['Since the "host" is not part of the stream, its own address is set to 255, ',(0,t.jsx)(n.code,{children:"GetAddr()"})," returns 255."]})}),"\n",(0,t.jsxs)(n.p,{children:["A device in ",(0,t.jsx)(n.code,{children:"Host()"})," mode is still listening uplink to commands but does not forward the commands downlink. This allows for programming, configuring the host, from DUELink ",(0,t.jsx)(n.a,{href:"../console",children:"Console"})," for example."]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);